using System;
using System.Collections.Generic;
using UnityEngine;

public class Graph
{
    /* https://gist.github.com/GibsS/fdba8e3cdbd307652fc3c01336b32534 */
    public static int CantorPairing(int i, int j) => (((i + j) * (i + j + 1)) / 2) + j;
    public static void ReverseCantorPairing(int m, out int i, out int j)
    {
        int t = (int)Math.Floor((-1 + Math.Sqrt(1 + 8 * m)) * 0.5f);
        i = t * (t + 3) / 2 - m;
        j = m - t * (t + 1) / 2;
    }

    // Grid that is used to build the graph.
    protected Enums.TerrainType[,] _grid;
    protected int _gridRowCount;
    protected int _gridColumnCount;
    public int GridRowCount => _gridRowCount;
    public int GridColumnCount => _gridColumnCount;

    // The size of the vertex. It's used to retrieve a vertex based on mouse position, for example.
    protected float _vertexSize;

    // The key for the dictionary is a unique number generated by a cantor pairing function
    // using which row and column the vertex is positioned on the grid.
    protected Dictionary<int, Vertex> _vertices;
    public Dictionary<int, Vertex> Vertices => _vertices;
    public int VerticesCount => _vertices.Count;

    /// <summary>
    /// Check if the given row and column indexes are contained in the grid.
    /// </summary>
    /// <param name="rowIndex"></param>
    /// <param name="columnIndex"></param>
    /// <returns></returns>
    public bool IsIndexValid(int rowIndex, int columnIndex) => rowIndex >= 0 && rowIndex < _gridRowCount && columnIndex >= 0 && columnIndex < _gridColumnCount;

    public Graph(Enums.TerrainType[,] grid, int rowCount, int columnCount, float vertexSize)
    {
        _gridRowCount = rowCount;
        _gridColumnCount = columnCount;
        _grid = grid;
        _vertices = new Dictionary<int, Vertex>(grid.Length);
        _vertexSize = vertexSize;
        GenerateGraph();
    }

    /// <summary>
    /// Create and add a vertex to the dictionary based on the given row and column.
    /// The grid will be used to determine the terrain type of the vertex.
    /// </summary>
    /// <param name="row"></param>
    /// <param name="column"></param>
    /// <returns></returns>
    public Vertex CreateVertex(int row, int column, bool shouldCreateWalls = true)
    {
        if (IsIndexValid(row, column))
        {
            if (!shouldCreateWalls && _grid[row, column] == Enums.TerrainType.Wall)
            {
                return null;
            }

            int identifier = CantorPairing(row, column);

            if (!_vertices.ContainsKey(identifier))
            {
                Vector2 vertexPosition;
                vertexPosition.x = column * _vertexSize + _vertexSize / 2;
                vertexPosition.y = row * _vertexSize + _vertexSize / 2;

                Vertex createdVertex = new Vertex(identifier, row, column, vertexPosition, _vertexSize, _grid[row, column]);

                _vertices.Add(createdVertex.Identifier, createdVertex);

                return createdVertex;
            }
        }

        return null;
    }

    /// <summary>
    /// Remove a vertex from the dictionary and remove all of its connections.
    /// </summary>
    /// <param name="vertex"></param>
    public void RemoveVertex(Vertex vertex)
    {
        if (_vertices.ContainsKey(vertex.Identifier))
        {
            foreach (Vertex connectedVertex in vertex.GetConnectedVertices())
            {
                connectedVertex.RemoveConnectedVertex(vertex);
            }

            _vertices.Remove(vertex.Identifier);
        }
    }

    /// <summary>
    /// Get a vertex based on a given world position.
    /// </summary>
    /// <param name="position"></param>
    /// <returns>
    /// Return the vertex if there is a vertex on the position or null if not.
    /// </returns>
    public Vertex GetVertexOnPosition(Vector2 position)
    {
        int rowIndex = (int)(position.y / _vertexSize);
        int columnIndex = (int)(position.x / _vertexSize);

        Vertex vertex;

        if (_vertices.TryGetValue(CantorPairing(rowIndex, columnIndex), out vertex))
        {
            return vertex;
        }

        return null;
    }

    protected virtual void GenerateGraph()
    {
        CreateVertices();
        CreateEdges();
    }

    protected virtual void CreateVertices()
    {
        for (int i = 0; i < _gridRowCount; i++)
        {
            for (int j = 0; j < _gridColumnCount; j++)
            {
                CreateVertex(i, j, false);
            }
        }
    }

    protected virtual void CreateEdges()
    {
        foreach (Vertex vertex in _vertices.Values)
        {
            if (vertex.TerrainType != Enums.TerrainType.Wall)
            {
                foreach (Vertex neighbour in GetVertexNeighbours(vertex))
                {
                    vertex.ConnectTo(neighbour);
                }
            }
        }
    }

    protected Vertex GetVertex(int rowIndex, int columnIndex)
    {
        if (IsIndexValid(rowIndex, columnIndex))
        {
            Vertex vertex;
            _vertices.TryGetValue(CantorPairing(rowIndex, columnIndex), out vertex);

            return vertex;
        }
        else
        {
            return null;
        }
    }

    /// <summary>
    /// Get all valid vertices surrounding a given vertex.
    /// </summary>
    /// For a neighbour be considered valid
    /// it must be:
    /// TerrainType != Wall
    /// If its a diagonal neighbour, we must check if there
    /// is a way that the vertex can access that neighbour. 
    /// <example>
    /// [0, W, 2]
    /// [3, 4, W]
    /// [6, 7, 8]
    /// W = Walls
    /// N = Vertex Identifier
    /// 
    /// Checking the neighbours of vertex 4.
    /// 3 and 7 are valid cardinal neighbours.
    /// 0, 6 and 8 are valid diagonal neighbours.
    /// 2 is invalid because there is no way you can access 2 from 4.
    /// There are two walls blocking the passage.
    /// </example>
    /// <param name="vertex"></param>
    /// <returns></returns>
    private Vertex[] GetVertexNeighbours(Vertex vertex)
    {
        List<Vertex> neighbours = new List<Vertex>();
        
        for (int i = -1; i < 2; i++)
        {
            for (int j = -1; j < 2; j++)
            {
                if (i == 0 && j == 0)
                {
                    continue;
                }

                Vertex neighbour = GetVertex(vertex.RowIndex + i, vertex.ColumnIndex + j);
                if (neighbour != null && neighbour.TerrainType != Enums.TerrainType.Wall)
                {
                    if (i != 0 && j != 0)
                    {
                        Vertex cardinalNeighbour = GetVertex(vertex.RowIndex + i, vertex.ColumnIndex);
                        if (cardinalNeighbour != null && cardinalNeighbour.TerrainType != Enums.TerrainType.Wall)
                        {
                            cardinalNeighbour = GetVertex(vertex.RowIndex, vertex.ColumnIndex + j);

                            if (cardinalNeighbour != null && cardinalNeighbour.TerrainType != Enums.TerrainType.Wall)
                            {
                                neighbours.Add(neighbour);
                            }
                        }
                    } else
                    {
                        neighbours.Add(neighbour);
                    }
                }
            }
        }

        return neighbours.ToArray();
    }
}
